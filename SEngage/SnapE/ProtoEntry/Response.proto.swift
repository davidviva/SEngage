// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source file Response.proto

import Foundation
import ProtocolBuffers


public func == (lhs: Status, rhs: Status) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: LoginResponse, rhs: LoginResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasErrtype == rhs.hasErrtype) && (!lhs.hasErrtype || lhs.errtype == rhs.errtype)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = fieldCheck && (lhs.hasSession == rhs.hasSession) && (!lhs.hasSession || lhs.session == rhs.session)
  fieldCheck = fieldCheck && (lhs.hasUser == rhs.hasUser) && (!lhs.hasUser || lhs.user == rhs.user)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ConnectResponse, rhs: ConnectResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasUser == rhs.hasUser) && (!lhs.hasUser || lhs.user == rhs.user)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ContactUpdateResponse, rhs: ContactUpdateResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.contacts == rhs.contacts)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: UserTeamUpdateResponse, rhs: UserTeamUpdateResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.teams == rhs.teams)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TeamUpdateResponse, rhs: TeamUpdateResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTeam == rhs.hasTeam) && (!lhs.hasTeam || lhs.team == rhs.team)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: UserAvatarNoticeResponse, rhs: UserAvatarNoticeResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUsername == rhs.hasUsername) && (!lhs.hasUsername || lhs.username == rhs.username)
  fieldCheck = fieldCheck && (lhs.hasAvatar == rhs.hasAvatar) && (!lhs.hasAvatar || lhs.avatar == rhs.avatar)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: TeamAvatarNoticeResponse, rhs: TeamAvatarNoticeResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTeamKey == rhs.hasTeamKey) && (!lhs.hasTeamKey || lhs.teamKey == rhs.teamKey)
  fieldCheck = fieldCheck && (lhs.hasAvatar == rhs.hasAvatar) && (!lhs.hasAvatar || lhs.avatar == rhs.avatar)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SearchContactResponse, rhs: SearchContactResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.results == rhs.results)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: UserAvatarChangeResponse, rhs: UserAvatarChangeResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ContactAddResponse, rhs: ContactAddResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasUser == rhs.hasUser) && (!lhs.hasUser || lhs.user == rhs.user)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ContactRemoveResponse, rhs: ContactRemoveResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasUsername == rhs.hasUsername) && (!lhs.hasUsername || lhs.username == rhs.username)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: StatusNoticeResponse, rhs: StatusNoticeResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasUsername == rhs.hasUsername) && (!lhs.hasUsername || lhs.username == rhs.username)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ChatMessageResponse, rhs: ChatMessageResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasSender == rhs.hasSender) && (!lhs.hasSender || lhs.sender == rhs.sender)
  fieldCheck = fieldCheck && (lhs.hasContent == rhs.hasContent) && (!lhs.hasContent || lhs.content == rhs.content)
  fieldCheck = fieldCheck && (lhs.hasMsgKey == rhs.hasMsgKey) && (!lhs.hasMsgKey || lhs.msgKey == rhs.msgKey)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: MessageRemoveResponse, rhs: MessageRemoveResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasMsgKey == rhs.hasMsgKey) && (!lhs.hasMsgKey || lhs.msgKey == rhs.msgKey)
  fieldCheck = fieldCheck && (lhs.hasIsTeam == rhs.hasIsTeam) && (!lhs.hasIsTeam || lhs.isTeam == rhs.isTeam)
  fieldCheck = fieldCheck && (lhs.hasSender == rhs.hasSender) && (!lhs.hasSender || lhs.sender == rhs.sender)
  fieldCheck = fieldCheck && (lhs.hasReceiver == rhs.hasReceiver) && (!lhs.hasReceiver || lhs.receiver == rhs.receiver)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: GroupCreateResponse, rhs: GroupCreateResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasTeam == rhs.hasTeam) && (!lhs.hasTeam || lhs.team == rhs.team)
  fieldCheck = fieldCheck && (lhs.hasAvatar == rhs.hasAvatar) && (!lhs.hasAvatar || lhs.avatar == rhs.avatar)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: GroupRemoveResponse, rhs: GroupRemoveResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasTeamKey == rhs.hasTeamKey) && (!lhs.hasTeamKey || lhs.teamKey == rhs.teamKey)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: GroupAddMemberResponse, rhs: GroupAddMemberResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasTeamKey == rhs.hasTeamKey) && (!lhs.hasTeamKey || lhs.teamKey == rhs.teamKey)
  fieldCheck = fieldCheck && (lhs.hasMember == rhs.hasMember) && (!lhs.hasMember || lhs.member == rhs.member)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: GroupRemoveMemberResponse, rhs: GroupRemoveMemberResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasTeamKey == rhs.hasTeamKey) && (!lhs.hasTeamKey || lhs.teamKey == rhs.teamKey)
  fieldCheck = fieldCheck && (lhs.hasMember == rhs.hasMember) && (!lhs.hasMember || lhs.member == rhs.member)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public struct ResponseRoot {
  public static var sharedInstance : ResponseRoot {
   struct Static {
       static let instance : ResponseRoot = ResponseRoot()
   }
   return Static.instance
  }
  public var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
    EntityRoot.sharedInstance.registerAllExtensions(extensionRegistry)
  }
  public func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

final public class Status : GeneratedMessage, GeneratedMessageProtocol {


    //Enum type declaration start 

    public enum Types:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case DefaultSuccess = 0
      case DefaultFailure = -1
      case ConnectFailed = 1
      case ConnectIllegal = 2
      case ConnectSessionExpired = 3
      case DisconnectSuccess = 7
      case DisconnectFailed = 8

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .DefaultSuccess: return ".DefaultSuccess"
              case .DefaultFailure: return ".DefaultFailure"
              case .ConnectFailed: return ".ConnectFailed"
              case .ConnectIllegal: return ".ConnectIllegal"
              case .ConnectSessionExpired: return ".ConnectSessionExpired"
              case .DisconnectSuccess: return ".DisconnectSuccess"
              case .DisconnectFailed: return ".DisconnectFailed"
          }
      }
    }

    //Enum type declaration end 

  public private(set) var types:Status.Types = Status.Types.DefaultSuccess
  public private(set) var hasTypes:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasTypes {
      try output.writeEnum(1, value:types.rawValue)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasTypes) {
      serialize_size += types.rawValue.computeEnumSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Status> {
    var mergedArray = Array<Status>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Status? {
    return try Status.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Status {
    return try Status.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Status {
    return try Status.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Status {
    return try Status.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Status {
    return try Status.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Status {
    return try Status.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Status {
    return try Status.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Status.Builder {
    return Status.classBuilder() as! Status.Builder
  }
  public func getBuilder() -> Status.Builder {
    return classBuilder() as! Status.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Status.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Status.Builder()
  }
  public func toBuilder() throws -> Status.Builder {
    return try Status.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Status) throws -> Status.Builder {
    return try Status.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if (hasTypes) {
      output += "\(indent) types: \(types.description)\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Status"
  }
  override public func className() -> String {
      return "Status"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Status.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Status = Status()
    public func getMessage() -> Status {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:Status.Types {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(value:Status.Types) -> Status.Builder {
        self.types = value
        return self
      }
      public func clearTypes() -> Status.Builder {
         builderResult.hasTypes = false
         builderResult.types = .DefaultSuccess
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Status.Builder {
      builderResult = Status()
      return self
    }
    public override func clone() throws -> Status.Builder {
      return try Status.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Status {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Status {
      let returnMe:Status = builderResult
      return returnMe
    }
    public func mergeFrom(other:Status) throws -> Status.Builder {
      if other == Status() {
       return self
      }
      if other.hasTypes {
           types = other.types
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Status.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Status.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          let valueInttypes = try input.readEnum()
          if let enumstypes = Status.Types(rawValue:valueInttypes){
               types = enumstypes
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueInttypes))
          }

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class LoginResponse : GeneratedMessage, GeneratedMessageProtocol {


    //Enum type declaration start 

    public enum ErrType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case Unknwon = 0
      case BadRequest = 1
      case InvalidUsername = 2
      case InvalidPassword = 3
      case NoUser = 4
      case AuthenticationFailure = 5
      case DefaultFailure = 6

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .Unknwon: return ".Unknwon"
              case .BadRequest: return ".BadRequest"
              case .InvalidUsername: return ".InvalidUsername"
              case .InvalidPassword: return ".InvalidPassword"
              case .NoUser: return ".NoUser"
              case .AuthenticationFailure: return ".AuthenticationFailure"
              case .DefaultFailure: return ".DefaultFailure"
          }
      }
    }

    //Enum type declaration end 

  public private(set) var errtype:LoginResponse.ErrType = LoginResponse.ErrType.Unknwon
  public private(set) var hasErrtype:Bool = false
  public private(set) var success:Bool = false

  public private(set) var hasSuccess:Bool = false
  public private(set) var session:Session!
  public private(set) var hasSession:Bool = false
  public private(set) var user:User!
  public private(set) var hasUser:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasErrtype {
      try output.writeEnum(1, value:errtype.rawValue)
    }
    if hasSuccess {
      try output.writeBool(2, value:success)
    }
    if hasSession {
      try output.writeMessage(3, value:session)
    }
    if hasUser {
      try output.writeMessage(4, value:user)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasErrtype) {
      serialize_size += errtype.rawValue.computeEnumSize(1)
    }
    if hasSuccess {
      serialize_size += success.computeBoolSize(2)
    }
    if hasSession {
        if let varSizesession = session?.computeMessageSize(3) {
            serialize_size += varSizesession
        }
    }
    if hasUser {
        if let varSizeuser = user?.computeMessageSize(4) {
            serialize_size += varSizeuser
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<LoginResponse> {
    var mergedArray = Array<LoginResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> LoginResponse? {
    return try LoginResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> LoginResponse {
    return try LoginResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> LoginResponse {
    return try LoginResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> LoginResponse {
    return try LoginResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> LoginResponse {
    return try LoginResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> LoginResponse {
    return try LoginResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> LoginResponse {
    return try LoginResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> LoginResponse.Builder {
    return LoginResponse.classBuilder() as! LoginResponse.Builder
  }
  public func getBuilder() -> LoginResponse.Builder {
    return classBuilder() as! LoginResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return LoginResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return LoginResponse.Builder()
  }
  public func toBuilder() throws -> LoginResponse.Builder {
    return try LoginResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:LoginResponse) throws -> LoginResponse.Builder {
    return try LoginResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if (hasErrtype) {
      output += "\(indent) errtype: \(errtype.description)\n"
    }
    if hasSuccess {
      output += "\(indent) success: \(success) \n"
    }
    if hasSession {
      output += "\(indent) session {\n"
      if let outDescSession = session {
        output += try outDescSession.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasUser {
      output += "\(indent) user {\n"
      if let outDescUser = user {
        output += try outDescUser.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasErrtype {
             hashCode = (hashCode &* 31) &+ Int(errtype.rawValue)
          }
          if hasSuccess {
             hashCode = (hashCode &* 31) &+ success.hashValue
          }
          if hasSession {
              if let hashValuesession = session?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuesession
              }
          }
          if hasUser {
              if let hashValueuser = user?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueuser
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "LoginResponse"
  }
  override public func className() -> String {
      return "LoginResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return LoginResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:LoginResponse = LoginResponse()
    public func getMessage() -> LoginResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasErrtype:Bool{
          get {
              return builderResult.hasErrtype
          }
      }
      public var errtype:LoginResponse.ErrType {
          get {
              return builderResult.errtype
          }
          set (value) {
              builderResult.hasErrtype = true
              builderResult.errtype = value
          }
      }
      public func setErrtype(value:LoginResponse.ErrType) -> LoginResponse.Builder {
        self.errtype = value
        return self
      }
      public func clearErrtype() -> LoginResponse.Builder {
         builderResult.hasErrtype = false
         builderResult.errtype = .Unknwon
         return self
      }
    public var hasSuccess:Bool {
         get {
              return builderResult.hasSuccess
         }
    }
    public var success:Bool {
         get {
              return builderResult.success
         }
         set (value) {
             builderResult.hasSuccess = true
             builderResult.success = value
         }
    }
    public func setSuccess(value:Bool) -> LoginResponse.Builder {
      self.success = value
      return self
    }
    public func clearSuccess() -> LoginResponse.Builder{
         builderResult.hasSuccess = false
         builderResult.success = false
         return self
    }
    public var hasSession:Bool {
         get {
             return builderResult.hasSession
         }
    }
    public var session:Session! {
         get {
             if sessionBuilder_ != nil {
                builderResult.session = sessionBuilder_.getMessage()
             }
             return builderResult.session
         }
         set (value) {
             builderResult.hasSession = true
             builderResult.session = value
         }
    }
    private var sessionBuilder_:Session.Builder! {
         didSet {
            builderResult.hasSession = true
         }
    }
    public func getSessionBuilder() -> Session.Builder {
      if sessionBuilder_ == nil {
         sessionBuilder_ = Session.Builder()
         builderResult.session = sessionBuilder_.getMessage()
         if session != nil {
            try! sessionBuilder_.mergeFrom(session)
         }
      }
      return sessionBuilder_
    }
    public func setSession(value:Session!) -> LoginResponse.Builder {
      self.session = value
      return self
    }
    public func mergeSession(value:Session) throws -> LoginResponse.Builder {
      if builderResult.hasSession {
        builderResult.session = try Session.builderWithPrototype(builderResult.session).mergeFrom(value).buildPartial()
      } else {
        builderResult.session = value
      }
      builderResult.hasSession = true
      return self
    }
    public func clearSession() -> LoginResponse.Builder {
      sessionBuilder_ = nil
      builderResult.hasSession = false
      builderResult.session = nil
      return self
    }
    public var hasUser:Bool {
         get {
             return builderResult.hasUser
         }
    }
    public var user:User! {
         get {
             if userBuilder_ != nil {
                builderResult.user = userBuilder_.getMessage()
             }
             return builderResult.user
         }
         set (value) {
             builderResult.hasUser = true
             builderResult.user = value
         }
    }
    private var userBuilder_:User.Builder! {
         didSet {
            builderResult.hasUser = true
         }
    }
    public func getUserBuilder() -> User.Builder {
      if userBuilder_ == nil {
         userBuilder_ = User.Builder()
         builderResult.user = userBuilder_.getMessage()
         if user != nil {
            try! userBuilder_.mergeFrom(user)
         }
      }
      return userBuilder_
    }
    public func setUser(value:User!) -> LoginResponse.Builder {
      self.user = value
      return self
    }
    public func mergeUser(value:User) throws -> LoginResponse.Builder {
      if builderResult.hasUser {
        builderResult.user = try User.builderWithPrototype(builderResult.user).mergeFrom(value).buildPartial()
      } else {
        builderResult.user = value
      }
      builderResult.hasUser = true
      return self
    }
    public func clearUser() -> LoginResponse.Builder {
      userBuilder_ = nil
      builderResult.hasUser = false
      builderResult.user = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> LoginResponse.Builder {
      builderResult = LoginResponse()
      return self
    }
    public override func clone() throws -> LoginResponse.Builder {
      return try LoginResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> LoginResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> LoginResponse {
      let returnMe:LoginResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:LoginResponse) throws -> LoginResponse.Builder {
      if other == LoginResponse() {
       return self
      }
      if other.hasErrtype {
           errtype = other.errtype
      }
      if other.hasSuccess {
           success = other.success
      }
      if (other.hasSession) {
          try mergeSession(other.session)
      }
      if (other.hasUser) {
          try mergeUser(other.user)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> LoginResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> LoginResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          let valueInterrtype = try input.readEnum()
          if let enumserrtype = LoginResponse.ErrType(rawValue:valueInterrtype){
               errtype = enumserrtype
          } else {
               try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueInterrtype))
          }

        case 16 :
          success = try input.readBool()

        case 26 :
          let subBuilder:Session.Builder = Session.Builder()
          if hasSession {
            try subBuilder.mergeFrom(session)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          session = subBuilder.buildPartial()

        case 34 :
          let subBuilder:User.Builder = User.Builder()
          if hasUser {
            try subBuilder.mergeFrom(user)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          user = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ConnectResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var status:Status!
  public private(set) var hasStatus:Bool = false
  public private(set) var user:User!
  public private(set) var hasUser:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasStatus {
      try output.writeMessage(1, value:status)
    }
    if hasUser {
      try output.writeMessage(2, value:user)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasStatus {
        if let varSizestatus = status?.computeMessageSize(1) {
            serialize_size += varSizestatus
        }
    }
    if hasUser {
        if let varSizeuser = user?.computeMessageSize(2) {
            serialize_size += varSizeuser
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ConnectResponse> {
    var mergedArray = Array<ConnectResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ConnectResponse? {
    return try ConnectResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> ConnectResponse {
    return try ConnectResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ConnectResponse {
    return try ConnectResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> ConnectResponse {
    return try ConnectResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ConnectResponse {
    return try ConnectResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ConnectResponse {
    return try ConnectResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConnectResponse {
    return try ConnectResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ConnectResponse.Builder {
    return ConnectResponse.classBuilder() as! ConnectResponse.Builder
  }
  public func getBuilder() -> ConnectResponse.Builder {
    return classBuilder() as! ConnectResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ConnectResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ConnectResponse.Builder()
  }
  public func toBuilder() throws -> ConnectResponse.Builder {
    return try ConnectResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:ConnectResponse) throws -> ConnectResponse.Builder {
    return try ConnectResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasStatus {
      output += "\(indent) status {\n"
      if let outDescStatus = status {
        output += try outDescStatus.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasUser {
      output += "\(indent) user {\n"
      if let outDescUser = user {
        output += try outDescUser.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasStatus {
              if let hashValuestatus = status?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuestatus
              }
          }
          if hasUser {
              if let hashValueuser = user?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueuser
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ConnectResponse"
  }
  override public func className() -> String {
      return "ConnectResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ConnectResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ConnectResponse = ConnectResponse()
    public func getMessage() -> ConnectResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasStatus:Bool {
         get {
             return builderResult.hasStatus
         }
    }
    public var status:Status! {
         get {
             if statusBuilder_ != nil {
                builderResult.status = statusBuilder_.getMessage()
             }
             return builderResult.status
         }
         set (value) {
             builderResult.hasStatus = true
             builderResult.status = value
         }
    }
    private var statusBuilder_:Status.Builder! {
         didSet {
            builderResult.hasStatus = true
         }
    }
    public func getStatusBuilder() -> Status.Builder {
      if statusBuilder_ == nil {
         statusBuilder_ = Status.Builder()
         builderResult.status = statusBuilder_.getMessage()
         if status != nil {
            try! statusBuilder_.mergeFrom(status)
         }
      }
      return statusBuilder_
    }
    public func setStatus(value:Status!) -> ConnectResponse.Builder {
      self.status = value
      return self
    }
    public func mergeStatus(value:Status) throws -> ConnectResponse.Builder {
      if builderResult.hasStatus {
        builderResult.status = try Status.builderWithPrototype(builderResult.status).mergeFrom(value).buildPartial()
      } else {
        builderResult.status = value
      }
      builderResult.hasStatus = true
      return self
    }
    public func clearStatus() -> ConnectResponse.Builder {
      statusBuilder_ = nil
      builderResult.hasStatus = false
      builderResult.status = nil
      return self
    }
    public var hasUser:Bool {
         get {
             return builderResult.hasUser
         }
    }
    public var user:User! {
         get {
             if userBuilder_ != nil {
                builderResult.user = userBuilder_.getMessage()
             }
             return builderResult.user
         }
         set (value) {
             builderResult.hasUser = true
             builderResult.user = value
         }
    }
    private var userBuilder_:User.Builder! {
         didSet {
            builderResult.hasUser = true
         }
    }
    public func getUserBuilder() -> User.Builder {
      if userBuilder_ == nil {
         userBuilder_ = User.Builder()
         builderResult.user = userBuilder_.getMessage()
         if user != nil {
            try! userBuilder_.mergeFrom(user)
         }
      }
      return userBuilder_
    }
    public func setUser(value:User!) -> ConnectResponse.Builder {
      self.user = value
      return self
    }
    public func mergeUser(value:User) throws -> ConnectResponse.Builder {
      if builderResult.hasUser {
        builderResult.user = try User.builderWithPrototype(builderResult.user).mergeFrom(value).buildPartial()
      } else {
        builderResult.user = value
      }
      builderResult.hasUser = true
      return self
    }
    public func clearUser() -> ConnectResponse.Builder {
      userBuilder_ = nil
      builderResult.hasUser = false
      builderResult.user = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ConnectResponse.Builder {
      builderResult = ConnectResponse()
      return self
    }
    public override func clone() throws -> ConnectResponse.Builder {
      return try ConnectResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ConnectResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ConnectResponse {
      let returnMe:ConnectResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:ConnectResponse) throws -> ConnectResponse.Builder {
      if other == ConnectResponse() {
       return self
      }
      if (other.hasStatus) {
          try mergeStatus(other.status)
      }
      if (other.hasUser) {
          try mergeUser(other.user)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ConnectResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ConnectResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder:Status.Builder = Status.Builder()
          if hasStatus {
            try subBuilder.mergeFrom(status)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          status = subBuilder.buildPartial()

        case 18 :
          let subBuilder:User.Builder = User.Builder()
          if hasUser {
            try subBuilder.mergeFrom(user)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          user = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ContactUpdateResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var contacts:Array<User>  = Array<User>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    for oneElementcontacts in contacts {
        try output.writeMessage(1, value:oneElementcontacts)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementcontacts in contacts {
        serialize_size += oneElementcontacts.computeMessageSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ContactUpdateResponse> {
    var mergedArray = Array<ContactUpdateResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ContactUpdateResponse? {
    return try ContactUpdateResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> ContactUpdateResponse {
    return try ContactUpdateResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ContactUpdateResponse {
    return try ContactUpdateResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> ContactUpdateResponse {
    return try ContactUpdateResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ContactUpdateResponse {
    return try ContactUpdateResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ContactUpdateResponse {
    return try ContactUpdateResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ContactUpdateResponse {
    return try ContactUpdateResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ContactUpdateResponse.Builder {
    return ContactUpdateResponse.classBuilder() as! ContactUpdateResponse.Builder
  }
  public func getBuilder() -> ContactUpdateResponse.Builder {
    return classBuilder() as! ContactUpdateResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ContactUpdateResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ContactUpdateResponse.Builder()
  }
  public func toBuilder() throws -> ContactUpdateResponse.Builder {
    return try ContactUpdateResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:ContactUpdateResponse) throws -> ContactUpdateResponse.Builder {
    return try ContactUpdateResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    var contactsElementIndex:Int = 0
    for oneElementcontacts in contacts {
        output += "\(indent) contacts[\(contactsElementIndex)] {\n"
        output += try oneElementcontacts.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        contactsElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementcontacts in contacts {
              hashCode = (hashCode &* 31) &+ oneElementcontacts.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ContactUpdateResponse"
  }
  override public func className() -> String {
      return "ContactUpdateResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ContactUpdateResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ContactUpdateResponse = ContactUpdateResponse()
    public func getMessage() -> ContactUpdateResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var contacts:Array<User> {
         get {
             return builderResult.contacts
         }
         set (value) {
             builderResult.contacts = value
         }
    }
    public func setContacts(value:Array<User>) -> ContactUpdateResponse.Builder {
      self.contacts = value
      return self
    }
    public func clearContacts() -> ContactUpdateResponse.Builder {
      builderResult.contacts.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ContactUpdateResponse.Builder {
      builderResult = ContactUpdateResponse()
      return self
    }
    public override func clone() throws -> ContactUpdateResponse.Builder {
      return try ContactUpdateResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ContactUpdateResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ContactUpdateResponse {
      let returnMe:ContactUpdateResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:ContactUpdateResponse) throws -> ContactUpdateResponse.Builder {
      if other == ContactUpdateResponse() {
       return self
      }
      if !other.contacts.isEmpty  {
         builderResult.contacts += other.contacts
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ContactUpdateResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ContactUpdateResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder = User.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          contacts += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class UserTeamUpdateResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var teams:Array<SimpleTeam>  = Array<SimpleTeam>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    for oneElementteams in teams {
        try output.writeMessage(1, value:oneElementteams)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementteams in teams {
        serialize_size += oneElementteams.computeMessageSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<UserTeamUpdateResponse> {
    var mergedArray = Array<UserTeamUpdateResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> UserTeamUpdateResponse? {
    return try UserTeamUpdateResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> UserTeamUpdateResponse {
    return try UserTeamUpdateResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> UserTeamUpdateResponse {
    return try UserTeamUpdateResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> UserTeamUpdateResponse {
    return try UserTeamUpdateResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> UserTeamUpdateResponse {
    return try UserTeamUpdateResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> UserTeamUpdateResponse {
    return try UserTeamUpdateResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserTeamUpdateResponse {
    return try UserTeamUpdateResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> UserTeamUpdateResponse.Builder {
    return UserTeamUpdateResponse.classBuilder() as! UserTeamUpdateResponse.Builder
  }
  public func getBuilder() -> UserTeamUpdateResponse.Builder {
    return classBuilder() as! UserTeamUpdateResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return UserTeamUpdateResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return UserTeamUpdateResponse.Builder()
  }
  public func toBuilder() throws -> UserTeamUpdateResponse.Builder {
    return try UserTeamUpdateResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:UserTeamUpdateResponse) throws -> UserTeamUpdateResponse.Builder {
    return try UserTeamUpdateResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    var teamsElementIndex:Int = 0
    for oneElementteams in teams {
        output += "\(indent) teams[\(teamsElementIndex)] {\n"
        output += try oneElementteams.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        teamsElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementteams in teams {
              hashCode = (hashCode &* 31) &+ oneElementteams.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "UserTeamUpdateResponse"
  }
  override public func className() -> String {
      return "UserTeamUpdateResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return UserTeamUpdateResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:UserTeamUpdateResponse = UserTeamUpdateResponse()
    public func getMessage() -> UserTeamUpdateResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var teams:Array<SimpleTeam> {
         get {
             return builderResult.teams
         }
         set (value) {
             builderResult.teams = value
         }
    }
    public func setTeams(value:Array<SimpleTeam>) -> UserTeamUpdateResponse.Builder {
      self.teams = value
      return self
    }
    public func clearTeams() -> UserTeamUpdateResponse.Builder {
      builderResult.teams.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> UserTeamUpdateResponse.Builder {
      builderResult = UserTeamUpdateResponse()
      return self
    }
    public override func clone() throws -> UserTeamUpdateResponse.Builder {
      return try UserTeamUpdateResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> UserTeamUpdateResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> UserTeamUpdateResponse {
      let returnMe:UserTeamUpdateResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:UserTeamUpdateResponse) throws -> UserTeamUpdateResponse.Builder {
      if other == UserTeamUpdateResponse() {
       return self
      }
      if !other.teams.isEmpty  {
         builderResult.teams += other.teams
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> UserTeamUpdateResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserTeamUpdateResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder = SimpleTeam.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          teams += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class TeamUpdateResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var team:Team!
  public private(set) var hasTeam:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasTeam {
      try output.writeMessage(1, value:team)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasTeam {
        if let varSizeteam = team?.computeMessageSize(1) {
            serialize_size += varSizeteam
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TeamUpdateResponse> {
    var mergedArray = Array<TeamUpdateResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TeamUpdateResponse? {
    return try TeamUpdateResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> TeamUpdateResponse {
    return try TeamUpdateResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TeamUpdateResponse {
    return try TeamUpdateResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> TeamUpdateResponse {
    return try TeamUpdateResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TeamUpdateResponse {
    return try TeamUpdateResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TeamUpdateResponse {
    return try TeamUpdateResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TeamUpdateResponse {
    return try TeamUpdateResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> TeamUpdateResponse.Builder {
    return TeamUpdateResponse.classBuilder() as! TeamUpdateResponse.Builder
  }
  public func getBuilder() -> TeamUpdateResponse.Builder {
    return classBuilder() as! TeamUpdateResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return TeamUpdateResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return TeamUpdateResponse.Builder()
  }
  public func toBuilder() throws -> TeamUpdateResponse.Builder {
    return try TeamUpdateResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:TeamUpdateResponse) throws -> TeamUpdateResponse.Builder {
    return try TeamUpdateResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasTeam {
      output += "\(indent) team {\n"
      if let outDescTeam = team {
        output += try outDescTeam.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTeam {
              if let hashValueteam = team?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueteam
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TeamUpdateResponse"
  }
  override public func className() -> String {
      return "TeamUpdateResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TeamUpdateResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:TeamUpdateResponse = TeamUpdateResponse()
    public func getMessage() -> TeamUpdateResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasTeam:Bool {
         get {
             return builderResult.hasTeam
         }
    }
    public var team:Team! {
         get {
             if teamBuilder_ != nil {
                builderResult.team = teamBuilder_.getMessage()
             }
             return builderResult.team
         }
         set (value) {
             builderResult.hasTeam = true
             builderResult.team = value
         }
    }
    private var teamBuilder_:Team.Builder! {
         didSet {
            builderResult.hasTeam = true
         }
    }
    public func getTeamBuilder() -> Team.Builder {
      if teamBuilder_ == nil {
         teamBuilder_ = Team.Builder()
         builderResult.team = teamBuilder_.getMessage()
         if team != nil {
            try! teamBuilder_.mergeFrom(team)
         }
      }
      return teamBuilder_
    }
    public func setTeam(value:Team!) -> TeamUpdateResponse.Builder {
      self.team = value
      return self
    }
    public func mergeTeam(value:Team) throws -> TeamUpdateResponse.Builder {
      if builderResult.hasTeam {
        builderResult.team = try Team.builderWithPrototype(builderResult.team).mergeFrom(value).buildPartial()
      } else {
        builderResult.team = value
      }
      builderResult.hasTeam = true
      return self
    }
    public func clearTeam() -> TeamUpdateResponse.Builder {
      teamBuilder_ = nil
      builderResult.hasTeam = false
      builderResult.team = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> TeamUpdateResponse.Builder {
      builderResult = TeamUpdateResponse()
      return self
    }
    public override func clone() throws -> TeamUpdateResponse.Builder {
      return try TeamUpdateResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> TeamUpdateResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> TeamUpdateResponse {
      let returnMe:TeamUpdateResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:TeamUpdateResponse) throws -> TeamUpdateResponse.Builder {
      if other == TeamUpdateResponse() {
       return self
      }
      if (other.hasTeam) {
          try mergeTeam(other.team)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TeamUpdateResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TeamUpdateResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder:Team.Builder = Team.Builder()
          if hasTeam {
            try subBuilder.mergeFrom(team)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          team = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class UserAvatarNoticeResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var username:String = ""

  public private(set) var hasUsername:Bool = false
  public private(set) var avatar:NSData = NSData()

  public private(set) var hasAvatar:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasUsername {
      try output.writeString(1, value:username)
    }
    if hasAvatar {
      try output.writeData(2, value:avatar)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasUsername {
      serialize_size += username.computeStringSize(1)
    }
    if hasAvatar {
      serialize_size += avatar.computeDataSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<UserAvatarNoticeResponse> {
    var mergedArray = Array<UserAvatarNoticeResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> UserAvatarNoticeResponse? {
    return try UserAvatarNoticeResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> UserAvatarNoticeResponse {
    return try UserAvatarNoticeResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> UserAvatarNoticeResponse {
    return try UserAvatarNoticeResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> UserAvatarNoticeResponse {
    return try UserAvatarNoticeResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> UserAvatarNoticeResponse {
    return try UserAvatarNoticeResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> UserAvatarNoticeResponse {
    return try UserAvatarNoticeResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserAvatarNoticeResponse {
    return try UserAvatarNoticeResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> UserAvatarNoticeResponse.Builder {
    return UserAvatarNoticeResponse.classBuilder() as! UserAvatarNoticeResponse.Builder
  }
  public func getBuilder() -> UserAvatarNoticeResponse.Builder {
    return classBuilder() as! UserAvatarNoticeResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return UserAvatarNoticeResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return UserAvatarNoticeResponse.Builder()
  }
  public func toBuilder() throws -> UserAvatarNoticeResponse.Builder {
    return try UserAvatarNoticeResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:UserAvatarNoticeResponse) throws -> UserAvatarNoticeResponse.Builder {
    return try UserAvatarNoticeResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasUsername {
      output += "\(indent) username: \(username) \n"
    }
    if hasAvatar {
      output += "\(indent) avatar: \(avatar) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasUsername {
             hashCode = (hashCode &* 31) &+ username.hashValue
          }
          if hasAvatar {
             hashCode = (hashCode &* 31) &+ avatar.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "UserAvatarNoticeResponse"
  }
  override public func className() -> String {
      return "UserAvatarNoticeResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return UserAvatarNoticeResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:UserAvatarNoticeResponse = UserAvatarNoticeResponse()
    public func getMessage() -> UserAvatarNoticeResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasUsername:Bool {
         get {
              return builderResult.hasUsername
         }
    }
    public var username:String {
         get {
              return builderResult.username
         }
         set (value) {
             builderResult.hasUsername = true
             builderResult.username = value
         }
    }
    public func setUsername(value:String) -> UserAvatarNoticeResponse.Builder {
      self.username = value
      return self
    }
    public func clearUsername() -> UserAvatarNoticeResponse.Builder{
         builderResult.hasUsername = false
         builderResult.username = ""
         return self
    }
    public var hasAvatar:Bool {
         get {
              return builderResult.hasAvatar
         }
    }
    public var avatar:NSData {
         get {
              return builderResult.avatar
         }
         set (value) {
             builderResult.hasAvatar = true
             builderResult.avatar = value
         }
    }
    public func setAvatar(value:NSData) -> UserAvatarNoticeResponse.Builder {
      self.avatar = value
      return self
    }
    public func clearAvatar() -> UserAvatarNoticeResponse.Builder{
         builderResult.hasAvatar = false
         builderResult.avatar = NSData()
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> UserAvatarNoticeResponse.Builder {
      builderResult = UserAvatarNoticeResponse()
      return self
    }
    public override func clone() throws -> UserAvatarNoticeResponse.Builder {
      return try UserAvatarNoticeResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> UserAvatarNoticeResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> UserAvatarNoticeResponse {
      let returnMe:UserAvatarNoticeResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:UserAvatarNoticeResponse) throws -> UserAvatarNoticeResponse.Builder {
      if other == UserAvatarNoticeResponse() {
       return self
      }
      if other.hasUsername {
           username = other.username
      }
      if other.hasAvatar {
           avatar = other.avatar
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> UserAvatarNoticeResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserAvatarNoticeResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          username = try input.readString()

        case 18 :
          avatar = try input.readData()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class TeamAvatarNoticeResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var teamKey:String = ""

  public private(set) var hasTeamKey:Bool = false
  public private(set) var avatar:NSData = NSData()

  public private(set) var hasAvatar:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasTeamKey {
      try output.writeString(1, value:teamKey)
    }
    if hasAvatar {
      try output.writeData(2, value:avatar)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasTeamKey {
      serialize_size += teamKey.computeStringSize(1)
    }
    if hasAvatar {
      serialize_size += avatar.computeDataSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<TeamAvatarNoticeResponse> {
    var mergedArray = Array<TeamAvatarNoticeResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> TeamAvatarNoticeResponse? {
    return try TeamAvatarNoticeResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> TeamAvatarNoticeResponse {
    return try TeamAvatarNoticeResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> TeamAvatarNoticeResponse {
    return try TeamAvatarNoticeResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> TeamAvatarNoticeResponse {
    return try TeamAvatarNoticeResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> TeamAvatarNoticeResponse {
    return try TeamAvatarNoticeResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> TeamAvatarNoticeResponse {
    return try TeamAvatarNoticeResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TeamAvatarNoticeResponse {
    return try TeamAvatarNoticeResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> TeamAvatarNoticeResponse.Builder {
    return TeamAvatarNoticeResponse.classBuilder() as! TeamAvatarNoticeResponse.Builder
  }
  public func getBuilder() -> TeamAvatarNoticeResponse.Builder {
    return classBuilder() as! TeamAvatarNoticeResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return TeamAvatarNoticeResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return TeamAvatarNoticeResponse.Builder()
  }
  public func toBuilder() throws -> TeamAvatarNoticeResponse.Builder {
    return try TeamAvatarNoticeResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:TeamAvatarNoticeResponse) throws -> TeamAvatarNoticeResponse.Builder {
    return try TeamAvatarNoticeResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasTeamKey {
      output += "\(indent) teamKey: \(teamKey) \n"
    }
    if hasAvatar {
      output += "\(indent) avatar: \(avatar) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTeamKey {
             hashCode = (hashCode &* 31) &+ teamKey.hashValue
          }
          if hasAvatar {
             hashCode = (hashCode &* 31) &+ avatar.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TeamAvatarNoticeResponse"
  }
  override public func className() -> String {
      return "TeamAvatarNoticeResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TeamAvatarNoticeResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:TeamAvatarNoticeResponse = TeamAvatarNoticeResponse()
    public func getMessage() -> TeamAvatarNoticeResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasTeamKey:Bool {
         get {
              return builderResult.hasTeamKey
         }
    }
    public var teamKey:String {
         get {
              return builderResult.teamKey
         }
         set (value) {
             builderResult.hasTeamKey = true
             builderResult.teamKey = value
         }
    }
    public func setTeamKey(value:String) -> TeamAvatarNoticeResponse.Builder {
      self.teamKey = value
      return self
    }
    public func clearTeamKey() -> TeamAvatarNoticeResponse.Builder{
         builderResult.hasTeamKey = false
         builderResult.teamKey = ""
         return self
    }
    public var hasAvatar:Bool {
         get {
              return builderResult.hasAvatar
         }
    }
    public var avatar:NSData {
         get {
              return builderResult.avatar
         }
         set (value) {
             builderResult.hasAvatar = true
             builderResult.avatar = value
         }
    }
    public func setAvatar(value:NSData) -> TeamAvatarNoticeResponse.Builder {
      self.avatar = value
      return self
    }
    public func clearAvatar() -> TeamAvatarNoticeResponse.Builder{
         builderResult.hasAvatar = false
         builderResult.avatar = NSData()
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> TeamAvatarNoticeResponse.Builder {
      builderResult = TeamAvatarNoticeResponse()
      return self
    }
    public override func clone() throws -> TeamAvatarNoticeResponse.Builder {
      return try TeamAvatarNoticeResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> TeamAvatarNoticeResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> TeamAvatarNoticeResponse {
      let returnMe:TeamAvatarNoticeResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:TeamAvatarNoticeResponse) throws -> TeamAvatarNoticeResponse.Builder {
      if other == TeamAvatarNoticeResponse() {
       return self
      }
      if other.hasTeamKey {
           teamKey = other.teamKey
      }
      if other.hasAvatar {
           avatar = other.avatar
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> TeamAvatarNoticeResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TeamAvatarNoticeResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          teamKey = try input.readString()

        case 18 :
          avatar = try input.readData()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SearchContactResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var results:Array<User>  = Array<User>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    for oneElementresults in results {
        try output.writeMessage(1, value:oneElementresults)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementresults in results {
        serialize_size += oneElementresults.computeMessageSize(1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<SearchContactResponse> {
    var mergedArray = Array<SearchContactResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> SearchContactResponse? {
    return try SearchContactResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> SearchContactResponse {
    return try SearchContactResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> SearchContactResponse {
    return try SearchContactResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> SearchContactResponse {
    return try SearchContactResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> SearchContactResponse {
    return try SearchContactResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> SearchContactResponse {
    return try SearchContactResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SearchContactResponse {
    return try SearchContactResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> SearchContactResponse.Builder {
    return SearchContactResponse.classBuilder() as! SearchContactResponse.Builder
  }
  public func getBuilder() -> SearchContactResponse.Builder {
    return classBuilder() as! SearchContactResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return SearchContactResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return SearchContactResponse.Builder()
  }
  public func toBuilder() throws -> SearchContactResponse.Builder {
    return try SearchContactResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:SearchContactResponse) throws -> SearchContactResponse.Builder {
    return try SearchContactResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    var resultsElementIndex:Int = 0
    for oneElementresults in results {
        output += "\(indent) results[\(resultsElementIndex)] {\n"
        output += try oneElementresults.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        resultsElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementresults in results {
              hashCode = (hashCode &* 31) &+ oneElementresults.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SearchContactResponse"
  }
  override public func className() -> String {
      return "SearchContactResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SearchContactResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SearchContactResponse = SearchContactResponse()
    public func getMessage() -> SearchContactResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var results:Array<User> {
         get {
             return builderResult.results
         }
         set (value) {
             builderResult.results = value
         }
    }
    public func setResults(value:Array<User>) -> SearchContactResponse.Builder {
      self.results = value
      return self
    }
    public func clearResults() -> SearchContactResponse.Builder {
      builderResult.results.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SearchContactResponse.Builder {
      builderResult = SearchContactResponse()
      return self
    }
    public override func clone() throws -> SearchContactResponse.Builder {
      return try SearchContactResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> SearchContactResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SearchContactResponse {
      let returnMe:SearchContactResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:SearchContactResponse) throws -> SearchContactResponse.Builder {
      if other == SearchContactResponse() {
       return self
      }
      if !other.results.isEmpty  {
         builderResult.results += other.results
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> SearchContactResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SearchContactResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder = User.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          results += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class UserAvatarChangeResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var status:Status!
  public private(set) var hasStatus:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasStatus {
      try output.writeMessage(1, value:status)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasStatus {
        if let varSizestatus = status?.computeMessageSize(1) {
            serialize_size += varSizestatus
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<UserAvatarChangeResponse> {
    var mergedArray = Array<UserAvatarChangeResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> UserAvatarChangeResponse? {
    return try UserAvatarChangeResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> UserAvatarChangeResponse {
    return try UserAvatarChangeResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> UserAvatarChangeResponse {
    return try UserAvatarChangeResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> UserAvatarChangeResponse {
    return try UserAvatarChangeResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> UserAvatarChangeResponse {
    return try UserAvatarChangeResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> UserAvatarChangeResponse {
    return try UserAvatarChangeResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserAvatarChangeResponse {
    return try UserAvatarChangeResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> UserAvatarChangeResponse.Builder {
    return UserAvatarChangeResponse.classBuilder() as! UserAvatarChangeResponse.Builder
  }
  public func getBuilder() -> UserAvatarChangeResponse.Builder {
    return classBuilder() as! UserAvatarChangeResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return UserAvatarChangeResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return UserAvatarChangeResponse.Builder()
  }
  public func toBuilder() throws -> UserAvatarChangeResponse.Builder {
    return try UserAvatarChangeResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:UserAvatarChangeResponse) throws -> UserAvatarChangeResponse.Builder {
    return try UserAvatarChangeResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasStatus {
      output += "\(indent) status {\n"
      if let outDescStatus = status {
        output += try outDescStatus.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasStatus {
              if let hashValuestatus = status?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuestatus
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "UserAvatarChangeResponse"
  }
  override public func className() -> String {
      return "UserAvatarChangeResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return UserAvatarChangeResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:UserAvatarChangeResponse = UserAvatarChangeResponse()
    public func getMessage() -> UserAvatarChangeResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasStatus:Bool {
         get {
             return builderResult.hasStatus
         }
    }
    public var status:Status! {
         get {
             if statusBuilder_ != nil {
                builderResult.status = statusBuilder_.getMessage()
             }
             return builderResult.status
         }
         set (value) {
             builderResult.hasStatus = true
             builderResult.status = value
         }
    }
    private var statusBuilder_:Status.Builder! {
         didSet {
            builderResult.hasStatus = true
         }
    }
    public func getStatusBuilder() -> Status.Builder {
      if statusBuilder_ == nil {
         statusBuilder_ = Status.Builder()
         builderResult.status = statusBuilder_.getMessage()
         if status != nil {
            try! statusBuilder_.mergeFrom(status)
         }
      }
      return statusBuilder_
    }
    public func setStatus(value:Status!) -> UserAvatarChangeResponse.Builder {
      self.status = value
      return self
    }
    public func mergeStatus(value:Status) throws -> UserAvatarChangeResponse.Builder {
      if builderResult.hasStatus {
        builderResult.status = try Status.builderWithPrototype(builderResult.status).mergeFrom(value).buildPartial()
      } else {
        builderResult.status = value
      }
      builderResult.hasStatus = true
      return self
    }
    public func clearStatus() -> UserAvatarChangeResponse.Builder {
      statusBuilder_ = nil
      builderResult.hasStatus = false
      builderResult.status = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> UserAvatarChangeResponse.Builder {
      builderResult = UserAvatarChangeResponse()
      return self
    }
    public override func clone() throws -> UserAvatarChangeResponse.Builder {
      return try UserAvatarChangeResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> UserAvatarChangeResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> UserAvatarChangeResponse {
      let returnMe:UserAvatarChangeResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:UserAvatarChangeResponse) throws -> UserAvatarChangeResponse.Builder {
      if other == UserAvatarChangeResponse() {
       return self
      }
      if (other.hasStatus) {
          try mergeStatus(other.status)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> UserAvatarChangeResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> UserAvatarChangeResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder:Status.Builder = Status.Builder()
          if hasStatus {
            try subBuilder.mergeFrom(status)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          status = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ContactAddResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var status:Status!
  public private(set) var hasStatus:Bool = false
  public private(set) var user:User!
  public private(set) var hasUser:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasStatus {
      try output.writeMessage(1, value:status)
    }
    if hasUser {
      try output.writeMessage(2, value:user)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasStatus {
        if let varSizestatus = status?.computeMessageSize(1) {
            serialize_size += varSizestatus
        }
    }
    if hasUser {
        if let varSizeuser = user?.computeMessageSize(2) {
            serialize_size += varSizeuser
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ContactAddResponse> {
    var mergedArray = Array<ContactAddResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ContactAddResponse? {
    return try ContactAddResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> ContactAddResponse {
    return try ContactAddResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ContactAddResponse {
    return try ContactAddResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> ContactAddResponse {
    return try ContactAddResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ContactAddResponse {
    return try ContactAddResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ContactAddResponse {
    return try ContactAddResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ContactAddResponse {
    return try ContactAddResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ContactAddResponse.Builder {
    return ContactAddResponse.classBuilder() as! ContactAddResponse.Builder
  }
  public func getBuilder() -> ContactAddResponse.Builder {
    return classBuilder() as! ContactAddResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ContactAddResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ContactAddResponse.Builder()
  }
  public func toBuilder() throws -> ContactAddResponse.Builder {
    return try ContactAddResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:ContactAddResponse) throws -> ContactAddResponse.Builder {
    return try ContactAddResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasStatus {
      output += "\(indent) status {\n"
      if let outDescStatus = status {
        output += try outDescStatus.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasUser {
      output += "\(indent) user {\n"
      if let outDescUser = user {
        output += try outDescUser.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasStatus {
              if let hashValuestatus = status?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuestatus
              }
          }
          if hasUser {
              if let hashValueuser = user?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueuser
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ContactAddResponse"
  }
  override public func className() -> String {
      return "ContactAddResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ContactAddResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ContactAddResponse = ContactAddResponse()
    public func getMessage() -> ContactAddResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasStatus:Bool {
         get {
             return builderResult.hasStatus
         }
    }
    public var status:Status! {
         get {
             if statusBuilder_ != nil {
                builderResult.status = statusBuilder_.getMessage()
             }
             return builderResult.status
         }
         set (value) {
             builderResult.hasStatus = true
             builderResult.status = value
         }
    }
    private var statusBuilder_:Status.Builder! {
         didSet {
            builderResult.hasStatus = true
         }
    }
    public func getStatusBuilder() -> Status.Builder {
      if statusBuilder_ == nil {
         statusBuilder_ = Status.Builder()
         builderResult.status = statusBuilder_.getMessage()
         if status != nil {
            try! statusBuilder_.mergeFrom(status)
         }
      }
      return statusBuilder_
    }
    public func setStatus(value:Status!) -> ContactAddResponse.Builder {
      self.status = value
      return self
    }
    public func mergeStatus(value:Status) throws -> ContactAddResponse.Builder {
      if builderResult.hasStatus {
        builderResult.status = try Status.builderWithPrototype(builderResult.status).mergeFrom(value).buildPartial()
      } else {
        builderResult.status = value
      }
      builderResult.hasStatus = true
      return self
    }
    public func clearStatus() -> ContactAddResponse.Builder {
      statusBuilder_ = nil
      builderResult.hasStatus = false
      builderResult.status = nil
      return self
    }
    public var hasUser:Bool {
         get {
             return builderResult.hasUser
         }
    }
    public var user:User! {
         get {
             if userBuilder_ != nil {
                builderResult.user = userBuilder_.getMessage()
             }
             return builderResult.user
         }
         set (value) {
             builderResult.hasUser = true
             builderResult.user = value
         }
    }
    private var userBuilder_:User.Builder! {
         didSet {
            builderResult.hasUser = true
         }
    }
    public func getUserBuilder() -> User.Builder {
      if userBuilder_ == nil {
         userBuilder_ = User.Builder()
         builderResult.user = userBuilder_.getMessage()
         if user != nil {
            try! userBuilder_.mergeFrom(user)
         }
      }
      return userBuilder_
    }
    public func setUser(value:User!) -> ContactAddResponse.Builder {
      self.user = value
      return self
    }
    public func mergeUser(value:User) throws -> ContactAddResponse.Builder {
      if builderResult.hasUser {
        builderResult.user = try User.builderWithPrototype(builderResult.user).mergeFrom(value).buildPartial()
      } else {
        builderResult.user = value
      }
      builderResult.hasUser = true
      return self
    }
    public func clearUser() -> ContactAddResponse.Builder {
      userBuilder_ = nil
      builderResult.hasUser = false
      builderResult.user = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ContactAddResponse.Builder {
      builderResult = ContactAddResponse()
      return self
    }
    public override func clone() throws -> ContactAddResponse.Builder {
      return try ContactAddResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ContactAddResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ContactAddResponse {
      let returnMe:ContactAddResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:ContactAddResponse) throws -> ContactAddResponse.Builder {
      if other == ContactAddResponse() {
       return self
      }
      if (other.hasStatus) {
          try mergeStatus(other.status)
      }
      if (other.hasUser) {
          try mergeUser(other.user)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ContactAddResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ContactAddResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder:Status.Builder = Status.Builder()
          if hasStatus {
            try subBuilder.mergeFrom(status)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          status = subBuilder.buildPartial()

        case 18 :
          let subBuilder:User.Builder = User.Builder()
          if hasUser {
            try subBuilder.mergeFrom(user)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          user = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ContactRemoveResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var status:Status!
  public private(set) var hasStatus:Bool = false
  public private(set) var username:String = ""

  public private(set) var hasUsername:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasStatus {
      try output.writeMessage(1, value:status)
    }
    if hasUsername {
      try output.writeString(2, value:username)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasStatus {
        if let varSizestatus = status?.computeMessageSize(1) {
            serialize_size += varSizestatus
        }
    }
    if hasUsername {
      serialize_size += username.computeStringSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ContactRemoveResponse> {
    var mergedArray = Array<ContactRemoveResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ContactRemoveResponse? {
    return try ContactRemoveResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> ContactRemoveResponse {
    return try ContactRemoveResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ContactRemoveResponse {
    return try ContactRemoveResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> ContactRemoveResponse {
    return try ContactRemoveResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ContactRemoveResponse {
    return try ContactRemoveResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ContactRemoveResponse {
    return try ContactRemoveResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ContactRemoveResponse {
    return try ContactRemoveResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ContactRemoveResponse.Builder {
    return ContactRemoveResponse.classBuilder() as! ContactRemoveResponse.Builder
  }
  public func getBuilder() -> ContactRemoveResponse.Builder {
    return classBuilder() as! ContactRemoveResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ContactRemoveResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ContactRemoveResponse.Builder()
  }
  public func toBuilder() throws -> ContactRemoveResponse.Builder {
    return try ContactRemoveResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:ContactRemoveResponse) throws -> ContactRemoveResponse.Builder {
    return try ContactRemoveResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasStatus {
      output += "\(indent) status {\n"
      if let outDescStatus = status {
        output += try outDescStatus.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasUsername {
      output += "\(indent) username: \(username) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasStatus {
              if let hashValuestatus = status?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuestatus
              }
          }
          if hasUsername {
             hashCode = (hashCode &* 31) &+ username.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ContactRemoveResponse"
  }
  override public func className() -> String {
      return "ContactRemoveResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ContactRemoveResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ContactRemoveResponse = ContactRemoveResponse()
    public func getMessage() -> ContactRemoveResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasStatus:Bool {
         get {
             return builderResult.hasStatus
         }
    }
    public var status:Status! {
         get {
             if statusBuilder_ != nil {
                builderResult.status = statusBuilder_.getMessage()
             }
             return builderResult.status
         }
         set (value) {
             builderResult.hasStatus = true
             builderResult.status = value
         }
    }
    private var statusBuilder_:Status.Builder! {
         didSet {
            builderResult.hasStatus = true
         }
    }
    public func getStatusBuilder() -> Status.Builder {
      if statusBuilder_ == nil {
         statusBuilder_ = Status.Builder()
         builderResult.status = statusBuilder_.getMessage()
         if status != nil {
            try! statusBuilder_.mergeFrom(status)
         }
      }
      return statusBuilder_
    }
    public func setStatus(value:Status!) -> ContactRemoveResponse.Builder {
      self.status = value
      return self
    }
    public func mergeStatus(value:Status) throws -> ContactRemoveResponse.Builder {
      if builderResult.hasStatus {
        builderResult.status = try Status.builderWithPrototype(builderResult.status).mergeFrom(value).buildPartial()
      } else {
        builderResult.status = value
      }
      builderResult.hasStatus = true
      return self
    }
    public func clearStatus() -> ContactRemoveResponse.Builder {
      statusBuilder_ = nil
      builderResult.hasStatus = false
      builderResult.status = nil
      return self
    }
    public var hasUsername:Bool {
         get {
              return builderResult.hasUsername
         }
    }
    public var username:String {
         get {
              return builderResult.username
         }
         set (value) {
             builderResult.hasUsername = true
             builderResult.username = value
         }
    }
    public func setUsername(value:String) -> ContactRemoveResponse.Builder {
      self.username = value
      return self
    }
    public func clearUsername() -> ContactRemoveResponse.Builder{
         builderResult.hasUsername = false
         builderResult.username = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ContactRemoveResponse.Builder {
      builderResult = ContactRemoveResponse()
      return self
    }
    public override func clone() throws -> ContactRemoveResponse.Builder {
      return try ContactRemoveResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ContactRemoveResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ContactRemoveResponse {
      let returnMe:ContactRemoveResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:ContactRemoveResponse) throws -> ContactRemoveResponse.Builder {
      if other == ContactRemoveResponse() {
       return self
      }
      if (other.hasStatus) {
          try mergeStatus(other.status)
      }
      if other.hasUsername {
           username = other.username
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ContactRemoveResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ContactRemoveResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder:Status.Builder = Status.Builder()
          if hasStatus {
            try subBuilder.mergeFrom(status)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          status = subBuilder.buildPartial()

        case 18 :
          username = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class StatusNoticeResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var status:Int32 = Int32(0)

  public private(set) var hasStatus:Bool = false
  public private(set) var username:String = ""

  public private(set) var hasUsername:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasStatus {
      try output.writeInt32(1, value:status)
    }
    if hasUsername {
      try output.writeString(2, value:username)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasStatus {
      serialize_size += status.computeInt32Size(1)
    }
    if hasUsername {
      serialize_size += username.computeStringSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<StatusNoticeResponse> {
    var mergedArray = Array<StatusNoticeResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> StatusNoticeResponse? {
    return try StatusNoticeResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> StatusNoticeResponse {
    return try StatusNoticeResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> StatusNoticeResponse {
    return try StatusNoticeResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> StatusNoticeResponse {
    return try StatusNoticeResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> StatusNoticeResponse {
    return try StatusNoticeResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> StatusNoticeResponse {
    return try StatusNoticeResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> StatusNoticeResponse {
    return try StatusNoticeResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> StatusNoticeResponse.Builder {
    return StatusNoticeResponse.classBuilder() as! StatusNoticeResponse.Builder
  }
  public func getBuilder() -> StatusNoticeResponse.Builder {
    return classBuilder() as! StatusNoticeResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return StatusNoticeResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return StatusNoticeResponse.Builder()
  }
  public func toBuilder() throws -> StatusNoticeResponse.Builder {
    return try StatusNoticeResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:StatusNoticeResponse) throws -> StatusNoticeResponse.Builder {
    return try StatusNoticeResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasStatus {
      output += "\(indent) status: \(status) \n"
    }
    if hasUsername {
      output += "\(indent) username: \(username) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasStatus {
             hashCode = (hashCode &* 31) &+ status.hashValue
          }
          if hasUsername {
             hashCode = (hashCode &* 31) &+ username.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "StatusNoticeResponse"
  }
  override public func className() -> String {
      return "StatusNoticeResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return StatusNoticeResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:StatusNoticeResponse = StatusNoticeResponse()
    public func getMessage() -> StatusNoticeResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasStatus:Bool {
         get {
              return builderResult.hasStatus
         }
    }
    public var status:Int32 {
         get {
              return builderResult.status
         }
         set (value) {
             builderResult.hasStatus = true
             builderResult.status = value
         }
    }
    public func setStatus(value:Int32) -> StatusNoticeResponse.Builder {
      self.status = value
      return self
    }
    public func clearStatus() -> StatusNoticeResponse.Builder{
         builderResult.hasStatus = false
         builderResult.status = Int32(0)
         return self
    }
    public var hasUsername:Bool {
         get {
              return builderResult.hasUsername
         }
    }
    public var username:String {
         get {
              return builderResult.username
         }
         set (value) {
             builderResult.hasUsername = true
             builderResult.username = value
         }
    }
    public func setUsername(value:String) -> StatusNoticeResponse.Builder {
      self.username = value
      return self
    }
    public func clearUsername() -> StatusNoticeResponse.Builder{
         builderResult.hasUsername = false
         builderResult.username = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> StatusNoticeResponse.Builder {
      builderResult = StatusNoticeResponse()
      return self
    }
    public override func clone() throws -> StatusNoticeResponse.Builder {
      return try StatusNoticeResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> StatusNoticeResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> StatusNoticeResponse {
      let returnMe:StatusNoticeResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:StatusNoticeResponse) throws -> StatusNoticeResponse.Builder {
      if other == StatusNoticeResponse() {
       return self
      }
      if other.hasStatus {
           status = other.status
      }
      if other.hasUsername {
           username = other.username
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> StatusNoticeResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> StatusNoticeResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          status = try input.readInt32()

        case 18 :
          username = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ChatMessageResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var status:Status!
  public private(set) var hasStatus:Bool = false
  public private(set) var sender:String = ""

  public private(set) var hasSender:Bool = false
  public private(set) var content:NSData = NSData()

  public private(set) var hasContent:Bool = false
  public private(set) var msgKey:String = ""

  public private(set) var hasMsgKey:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasStatus {
      try output.writeMessage(1, value:status)
    }
    if hasSender {
      try output.writeString(2, value:sender)
    }
    if hasContent {
      try output.writeData(3, value:content)
    }
    if hasMsgKey {
      try output.writeString(4, value:msgKey)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasStatus {
        if let varSizestatus = status?.computeMessageSize(1) {
            serialize_size += varSizestatus
        }
    }
    if hasSender {
      serialize_size += sender.computeStringSize(2)
    }
    if hasContent {
      serialize_size += content.computeDataSize(3)
    }
    if hasMsgKey {
      serialize_size += msgKey.computeStringSize(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ChatMessageResponse> {
    var mergedArray = Array<ChatMessageResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ChatMessageResponse? {
    return try ChatMessageResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> ChatMessageResponse {
    return try ChatMessageResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ChatMessageResponse {
    return try ChatMessageResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> ChatMessageResponse {
    return try ChatMessageResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ChatMessageResponse {
    return try ChatMessageResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ChatMessageResponse {
    return try ChatMessageResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ChatMessageResponse {
    return try ChatMessageResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ChatMessageResponse.Builder {
    return ChatMessageResponse.classBuilder() as! ChatMessageResponse.Builder
  }
  public func getBuilder() -> ChatMessageResponse.Builder {
    return classBuilder() as! ChatMessageResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ChatMessageResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ChatMessageResponse.Builder()
  }
  public func toBuilder() throws -> ChatMessageResponse.Builder {
    return try ChatMessageResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:ChatMessageResponse) throws -> ChatMessageResponse.Builder {
    return try ChatMessageResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasStatus {
      output += "\(indent) status {\n"
      if let outDescStatus = status {
        output += try outDescStatus.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasSender {
      output += "\(indent) sender: \(sender) \n"
    }
    if hasContent {
      output += "\(indent) content: \(content) \n"
    }
    if hasMsgKey {
      output += "\(indent) msgKey: \(msgKey) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasStatus {
              if let hashValuestatus = status?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuestatus
              }
          }
          if hasSender {
             hashCode = (hashCode &* 31) &+ sender.hashValue
          }
          if hasContent {
             hashCode = (hashCode &* 31) &+ content.hashValue
          }
          if hasMsgKey {
             hashCode = (hashCode &* 31) &+ msgKey.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ChatMessageResponse"
  }
  override public func className() -> String {
      return "ChatMessageResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ChatMessageResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ChatMessageResponse = ChatMessageResponse()
    public func getMessage() -> ChatMessageResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasStatus:Bool {
         get {
             return builderResult.hasStatus
         }
    }
    public var status:Status! {
         get {
             if statusBuilder_ != nil {
                builderResult.status = statusBuilder_.getMessage()
             }
             return builderResult.status
         }
         set (value) {
             builderResult.hasStatus = true
             builderResult.status = value
         }
    }
    private var statusBuilder_:Status.Builder! {
         didSet {
            builderResult.hasStatus = true
         }
    }
    public func getStatusBuilder() -> Status.Builder {
      if statusBuilder_ == nil {
         statusBuilder_ = Status.Builder()
         builderResult.status = statusBuilder_.getMessage()
         if status != nil {
            try! statusBuilder_.mergeFrom(status)
         }
      }
      return statusBuilder_
    }
    public func setStatus(value:Status!) -> ChatMessageResponse.Builder {
      self.status = value
      return self
    }
    public func mergeStatus(value:Status) throws -> ChatMessageResponse.Builder {
      if builderResult.hasStatus {
        builderResult.status = try Status.builderWithPrototype(builderResult.status).mergeFrom(value).buildPartial()
      } else {
        builderResult.status = value
      }
      builderResult.hasStatus = true
      return self
    }
    public func clearStatus() -> ChatMessageResponse.Builder {
      statusBuilder_ = nil
      builderResult.hasStatus = false
      builderResult.status = nil
      return self
    }
    public var hasSender:Bool {
         get {
              return builderResult.hasSender
         }
    }
    public var sender:String {
         get {
              return builderResult.sender
         }
         set (value) {
             builderResult.hasSender = true
             builderResult.sender = value
         }
    }
    public func setSender(value:String) -> ChatMessageResponse.Builder {
      self.sender = value
      return self
    }
    public func clearSender() -> ChatMessageResponse.Builder{
         builderResult.hasSender = false
         builderResult.sender = ""
         return self
    }
    public var hasContent:Bool {
         get {
              return builderResult.hasContent
         }
    }
    public var content:NSData {
         get {
              return builderResult.content
         }
         set (value) {
             builderResult.hasContent = true
             builderResult.content = value
         }
    }
    public func setContent(value:NSData) -> ChatMessageResponse.Builder {
      self.content = value
      return self
    }
    public func clearContent() -> ChatMessageResponse.Builder{
         builderResult.hasContent = false
         builderResult.content = NSData()
         return self
    }
    public var hasMsgKey:Bool {
         get {
              return builderResult.hasMsgKey
         }
    }
    public var msgKey:String {
         get {
              return builderResult.msgKey
         }
         set (value) {
             builderResult.hasMsgKey = true
             builderResult.msgKey = value
         }
    }
    public func setMsgKey(value:String) -> ChatMessageResponse.Builder {
      self.msgKey = value
      return self
    }
    public func clearMsgKey() -> ChatMessageResponse.Builder{
         builderResult.hasMsgKey = false
         builderResult.msgKey = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ChatMessageResponse.Builder {
      builderResult = ChatMessageResponse()
      return self
    }
    public override func clone() throws -> ChatMessageResponse.Builder {
      return try ChatMessageResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ChatMessageResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ChatMessageResponse {
      let returnMe:ChatMessageResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:ChatMessageResponse) throws -> ChatMessageResponse.Builder {
      if other == ChatMessageResponse() {
       return self
      }
      if (other.hasStatus) {
          try mergeStatus(other.status)
      }
      if other.hasSender {
           sender = other.sender
      }
      if other.hasContent {
           content = other.content
      }
      if other.hasMsgKey {
           msgKey = other.msgKey
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ChatMessageResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ChatMessageResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder:Status.Builder = Status.Builder()
          if hasStatus {
            try subBuilder.mergeFrom(status)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          status = subBuilder.buildPartial()

        case 18 :
          sender = try input.readString()

        case 26 :
          content = try input.readData()

        case 34 :
          msgKey = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class MessageRemoveResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var status:Status!
  public private(set) var hasStatus:Bool = false
  public private(set) var msgKey:String = ""

  public private(set) var hasMsgKey:Bool = false
  public private(set) var isTeam:Bool = false

  public private(set) var hasIsTeam:Bool = false
  public private(set) var sender:String = ""

  public private(set) var hasSender:Bool = false
  public private(set) var receiver:String = ""

  public private(set) var hasReceiver:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasStatus {
      try output.writeMessage(1, value:status)
    }
    if hasMsgKey {
      try output.writeString(2, value:msgKey)
    }
    if hasIsTeam {
      try output.writeBool(3, value:isTeam)
    }
    if hasSender {
      try output.writeString(4, value:sender)
    }
    if hasReceiver {
      try output.writeString(5, value:receiver)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasStatus {
        if let varSizestatus = status?.computeMessageSize(1) {
            serialize_size += varSizestatus
        }
    }
    if hasMsgKey {
      serialize_size += msgKey.computeStringSize(2)
    }
    if hasIsTeam {
      serialize_size += isTeam.computeBoolSize(3)
    }
    if hasSender {
      serialize_size += sender.computeStringSize(4)
    }
    if hasReceiver {
      serialize_size += receiver.computeStringSize(5)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<MessageRemoveResponse> {
    var mergedArray = Array<MessageRemoveResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> MessageRemoveResponse? {
    return try MessageRemoveResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> MessageRemoveResponse {
    return try MessageRemoveResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> MessageRemoveResponse {
    return try MessageRemoveResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> MessageRemoveResponse {
    return try MessageRemoveResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> MessageRemoveResponse {
    return try MessageRemoveResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> MessageRemoveResponse {
    return try MessageRemoveResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MessageRemoveResponse {
    return try MessageRemoveResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> MessageRemoveResponse.Builder {
    return MessageRemoveResponse.classBuilder() as! MessageRemoveResponse.Builder
  }
  public func getBuilder() -> MessageRemoveResponse.Builder {
    return classBuilder() as! MessageRemoveResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return MessageRemoveResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return MessageRemoveResponse.Builder()
  }
  public func toBuilder() throws -> MessageRemoveResponse.Builder {
    return try MessageRemoveResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:MessageRemoveResponse) throws -> MessageRemoveResponse.Builder {
    return try MessageRemoveResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasStatus {
      output += "\(indent) status {\n"
      if let outDescStatus = status {
        output += try outDescStatus.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasMsgKey {
      output += "\(indent) msgKey: \(msgKey) \n"
    }
    if hasIsTeam {
      output += "\(indent) isTeam: \(isTeam) \n"
    }
    if hasSender {
      output += "\(indent) sender: \(sender) \n"
    }
    if hasReceiver {
      output += "\(indent) receiver: \(receiver) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasStatus {
              if let hashValuestatus = status?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuestatus
              }
          }
          if hasMsgKey {
             hashCode = (hashCode &* 31) &+ msgKey.hashValue
          }
          if hasIsTeam {
             hashCode = (hashCode &* 31) &+ isTeam.hashValue
          }
          if hasSender {
             hashCode = (hashCode &* 31) &+ sender.hashValue
          }
          if hasReceiver {
             hashCode = (hashCode &* 31) &+ receiver.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MessageRemoveResponse"
  }
  override public func className() -> String {
      return "MessageRemoveResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return MessageRemoveResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:MessageRemoveResponse = MessageRemoveResponse()
    public func getMessage() -> MessageRemoveResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasStatus:Bool {
         get {
             return builderResult.hasStatus
         }
    }
    public var status:Status! {
         get {
             if statusBuilder_ != nil {
                builderResult.status = statusBuilder_.getMessage()
             }
             return builderResult.status
         }
         set (value) {
             builderResult.hasStatus = true
             builderResult.status = value
         }
    }
    private var statusBuilder_:Status.Builder! {
         didSet {
            builderResult.hasStatus = true
         }
    }
    public func getStatusBuilder() -> Status.Builder {
      if statusBuilder_ == nil {
         statusBuilder_ = Status.Builder()
         builderResult.status = statusBuilder_.getMessage()
         if status != nil {
            try! statusBuilder_.mergeFrom(status)
         }
      }
      return statusBuilder_
    }
    public func setStatus(value:Status!) -> MessageRemoveResponse.Builder {
      self.status = value
      return self
    }
    public func mergeStatus(value:Status) throws -> MessageRemoveResponse.Builder {
      if builderResult.hasStatus {
        builderResult.status = try Status.builderWithPrototype(builderResult.status).mergeFrom(value).buildPartial()
      } else {
        builderResult.status = value
      }
      builderResult.hasStatus = true
      return self
    }
    public func clearStatus() -> MessageRemoveResponse.Builder {
      statusBuilder_ = nil
      builderResult.hasStatus = false
      builderResult.status = nil
      return self
    }
    public var hasMsgKey:Bool {
         get {
              return builderResult.hasMsgKey
         }
    }
    public var msgKey:String {
         get {
              return builderResult.msgKey
         }
         set (value) {
             builderResult.hasMsgKey = true
             builderResult.msgKey = value
         }
    }
    public func setMsgKey(value:String) -> MessageRemoveResponse.Builder {
      self.msgKey = value
      return self
    }
    public func clearMsgKey() -> MessageRemoveResponse.Builder{
         builderResult.hasMsgKey = false
         builderResult.msgKey = ""
         return self
    }
    public var hasIsTeam:Bool {
         get {
              return builderResult.hasIsTeam
         }
    }
    public var isTeam:Bool {
         get {
              return builderResult.isTeam
         }
         set (value) {
             builderResult.hasIsTeam = true
             builderResult.isTeam = value
         }
    }
    public func setIsTeam(value:Bool) -> MessageRemoveResponse.Builder {
      self.isTeam = value
      return self
    }
    public func clearIsTeam() -> MessageRemoveResponse.Builder{
         builderResult.hasIsTeam = false
         builderResult.isTeam = false
         return self
    }
    public var hasSender:Bool {
         get {
              return builderResult.hasSender
         }
    }
    public var sender:String {
         get {
              return builderResult.sender
         }
         set (value) {
             builderResult.hasSender = true
             builderResult.sender = value
         }
    }
    public func setSender(value:String) -> MessageRemoveResponse.Builder {
      self.sender = value
      return self
    }
    public func clearSender() -> MessageRemoveResponse.Builder{
         builderResult.hasSender = false
         builderResult.sender = ""
         return self
    }
    public var hasReceiver:Bool {
         get {
              return builderResult.hasReceiver
         }
    }
    public var receiver:String {
         get {
              return builderResult.receiver
         }
         set (value) {
             builderResult.hasReceiver = true
             builderResult.receiver = value
         }
    }
    public func setReceiver(value:String) -> MessageRemoveResponse.Builder {
      self.receiver = value
      return self
    }
    public func clearReceiver() -> MessageRemoveResponse.Builder{
         builderResult.hasReceiver = false
         builderResult.receiver = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> MessageRemoveResponse.Builder {
      builderResult = MessageRemoveResponse()
      return self
    }
    public override func clone() throws -> MessageRemoveResponse.Builder {
      return try MessageRemoveResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> MessageRemoveResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> MessageRemoveResponse {
      let returnMe:MessageRemoveResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:MessageRemoveResponse) throws -> MessageRemoveResponse.Builder {
      if other == MessageRemoveResponse() {
       return self
      }
      if (other.hasStatus) {
          try mergeStatus(other.status)
      }
      if other.hasMsgKey {
           msgKey = other.msgKey
      }
      if other.hasIsTeam {
           isTeam = other.isTeam
      }
      if other.hasSender {
           sender = other.sender
      }
      if other.hasReceiver {
           receiver = other.receiver
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> MessageRemoveResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MessageRemoveResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder:Status.Builder = Status.Builder()
          if hasStatus {
            try subBuilder.mergeFrom(status)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          status = subBuilder.buildPartial()

        case 18 :
          msgKey = try input.readString()

        case 24 :
          isTeam = try input.readBool()

        case 34 :
          sender = try input.readString()

        case 42 :
          receiver = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class GroupCreateResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var status:Status!
  public private(set) var hasStatus:Bool = false
  public private(set) var team:Team!
  public private(set) var hasTeam:Bool = false
  public private(set) var avatar:NSData = NSData()

  public private(set) var hasAvatar:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasStatus {
      try output.writeMessage(1, value:status)
    }
    if hasTeam {
      try output.writeMessage(2, value:team)
    }
    if hasAvatar {
      try output.writeData(3, value:avatar)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasStatus {
        if let varSizestatus = status?.computeMessageSize(1) {
            serialize_size += varSizestatus
        }
    }
    if hasTeam {
        if let varSizeteam = team?.computeMessageSize(2) {
            serialize_size += varSizeteam
        }
    }
    if hasAvatar {
      serialize_size += avatar.computeDataSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<GroupCreateResponse> {
    var mergedArray = Array<GroupCreateResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> GroupCreateResponse? {
    return try GroupCreateResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> GroupCreateResponse {
    return try GroupCreateResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> GroupCreateResponse {
    return try GroupCreateResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> GroupCreateResponse {
    return try GroupCreateResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> GroupCreateResponse {
    return try GroupCreateResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> GroupCreateResponse {
    return try GroupCreateResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GroupCreateResponse {
    return try GroupCreateResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> GroupCreateResponse.Builder {
    return GroupCreateResponse.classBuilder() as! GroupCreateResponse.Builder
  }
  public func getBuilder() -> GroupCreateResponse.Builder {
    return classBuilder() as! GroupCreateResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return GroupCreateResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return GroupCreateResponse.Builder()
  }
  public func toBuilder() throws -> GroupCreateResponse.Builder {
    return try GroupCreateResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:GroupCreateResponse) throws -> GroupCreateResponse.Builder {
    return try GroupCreateResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasStatus {
      output += "\(indent) status {\n"
      if let outDescStatus = status {
        output += try outDescStatus.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasTeam {
      output += "\(indent) team {\n"
      if let outDescTeam = team {
        output += try outDescTeam.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasAvatar {
      output += "\(indent) avatar: \(avatar) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasStatus {
              if let hashValuestatus = status?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuestatus
              }
          }
          if hasTeam {
              if let hashValueteam = team?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueteam
              }
          }
          if hasAvatar {
             hashCode = (hashCode &* 31) &+ avatar.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "GroupCreateResponse"
  }
  override public func className() -> String {
      return "GroupCreateResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return GroupCreateResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:GroupCreateResponse = GroupCreateResponse()
    public func getMessage() -> GroupCreateResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasStatus:Bool {
         get {
             return builderResult.hasStatus
         }
    }
    public var status:Status! {
         get {
             if statusBuilder_ != nil {
                builderResult.status = statusBuilder_.getMessage()
             }
             return builderResult.status
         }
         set (value) {
             builderResult.hasStatus = true
             builderResult.status = value
         }
    }
    private var statusBuilder_:Status.Builder! {
         didSet {
            builderResult.hasStatus = true
         }
    }
    public func getStatusBuilder() -> Status.Builder {
      if statusBuilder_ == nil {
         statusBuilder_ = Status.Builder()
         builderResult.status = statusBuilder_.getMessage()
         if status != nil {
            try! statusBuilder_.mergeFrom(status)
         }
      }
      return statusBuilder_
    }
    public func setStatus(value:Status!) -> GroupCreateResponse.Builder {
      self.status = value
      return self
    }
    public func mergeStatus(value:Status) throws -> GroupCreateResponse.Builder {
      if builderResult.hasStatus {
        builderResult.status = try Status.builderWithPrototype(builderResult.status).mergeFrom(value).buildPartial()
      } else {
        builderResult.status = value
      }
      builderResult.hasStatus = true
      return self
    }
    public func clearStatus() -> GroupCreateResponse.Builder {
      statusBuilder_ = nil
      builderResult.hasStatus = false
      builderResult.status = nil
      return self
    }
    public var hasTeam:Bool {
         get {
             return builderResult.hasTeam
         }
    }
    public var team:Team! {
         get {
             if teamBuilder_ != nil {
                builderResult.team = teamBuilder_.getMessage()
             }
             return builderResult.team
         }
         set (value) {
             builderResult.hasTeam = true
             builderResult.team = value
         }
    }
    private var teamBuilder_:Team.Builder! {
         didSet {
            builderResult.hasTeam = true
         }
    }
    public func getTeamBuilder() -> Team.Builder {
      if teamBuilder_ == nil {
         teamBuilder_ = Team.Builder()
         builderResult.team = teamBuilder_.getMessage()
         if team != nil {
            try! teamBuilder_.mergeFrom(team)
         }
      }
      return teamBuilder_
    }
    public func setTeam(value:Team!) -> GroupCreateResponse.Builder {
      self.team = value
      return self
    }
    public func mergeTeam(value:Team) throws -> GroupCreateResponse.Builder {
      if builderResult.hasTeam {
        builderResult.team = try Team.builderWithPrototype(builderResult.team).mergeFrom(value).buildPartial()
      } else {
        builderResult.team = value
      }
      builderResult.hasTeam = true
      return self
    }
    public func clearTeam() -> GroupCreateResponse.Builder {
      teamBuilder_ = nil
      builderResult.hasTeam = false
      builderResult.team = nil
      return self
    }
    public var hasAvatar:Bool {
         get {
              return builderResult.hasAvatar
         }
    }
    public var avatar:NSData {
         get {
              return builderResult.avatar
         }
         set (value) {
             builderResult.hasAvatar = true
             builderResult.avatar = value
         }
    }
    public func setAvatar(value:NSData) -> GroupCreateResponse.Builder {
      self.avatar = value
      return self
    }
    public func clearAvatar() -> GroupCreateResponse.Builder{
         builderResult.hasAvatar = false
         builderResult.avatar = NSData()
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> GroupCreateResponse.Builder {
      builderResult = GroupCreateResponse()
      return self
    }
    public override func clone() throws -> GroupCreateResponse.Builder {
      return try GroupCreateResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> GroupCreateResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> GroupCreateResponse {
      let returnMe:GroupCreateResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:GroupCreateResponse) throws -> GroupCreateResponse.Builder {
      if other == GroupCreateResponse() {
       return self
      }
      if (other.hasStatus) {
          try mergeStatus(other.status)
      }
      if (other.hasTeam) {
          try mergeTeam(other.team)
      }
      if other.hasAvatar {
           avatar = other.avatar
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> GroupCreateResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GroupCreateResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder:Status.Builder = Status.Builder()
          if hasStatus {
            try subBuilder.mergeFrom(status)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          status = subBuilder.buildPartial()

        case 18 :
          let subBuilder:Team.Builder = Team.Builder()
          if hasTeam {
            try subBuilder.mergeFrom(team)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          team = subBuilder.buildPartial()

        case 26 :
          avatar = try input.readData()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class GroupRemoveResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var status:Status!
  public private(set) var hasStatus:Bool = false
  public private(set) var teamKey:String = ""

  public private(set) var hasTeamKey:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasStatus {
      try output.writeMessage(1, value:status)
    }
    if hasTeamKey {
      try output.writeString(2, value:teamKey)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasStatus {
        if let varSizestatus = status?.computeMessageSize(1) {
            serialize_size += varSizestatus
        }
    }
    if hasTeamKey {
      serialize_size += teamKey.computeStringSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<GroupRemoveResponse> {
    var mergedArray = Array<GroupRemoveResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> GroupRemoveResponse? {
    return try GroupRemoveResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> GroupRemoveResponse {
    return try GroupRemoveResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> GroupRemoveResponse {
    return try GroupRemoveResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> GroupRemoveResponse {
    return try GroupRemoveResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> GroupRemoveResponse {
    return try GroupRemoveResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> GroupRemoveResponse {
    return try GroupRemoveResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GroupRemoveResponse {
    return try GroupRemoveResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> GroupRemoveResponse.Builder {
    return GroupRemoveResponse.classBuilder() as! GroupRemoveResponse.Builder
  }
  public func getBuilder() -> GroupRemoveResponse.Builder {
    return classBuilder() as! GroupRemoveResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return GroupRemoveResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return GroupRemoveResponse.Builder()
  }
  public func toBuilder() throws -> GroupRemoveResponse.Builder {
    return try GroupRemoveResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:GroupRemoveResponse) throws -> GroupRemoveResponse.Builder {
    return try GroupRemoveResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasStatus {
      output += "\(indent) status {\n"
      if let outDescStatus = status {
        output += try outDescStatus.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasTeamKey {
      output += "\(indent) teamKey: \(teamKey) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasStatus {
              if let hashValuestatus = status?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuestatus
              }
          }
          if hasTeamKey {
             hashCode = (hashCode &* 31) &+ teamKey.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "GroupRemoveResponse"
  }
  override public func className() -> String {
      return "GroupRemoveResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return GroupRemoveResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:GroupRemoveResponse = GroupRemoveResponse()
    public func getMessage() -> GroupRemoveResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasStatus:Bool {
         get {
             return builderResult.hasStatus
         }
    }
    public var status:Status! {
         get {
             if statusBuilder_ != nil {
                builderResult.status = statusBuilder_.getMessage()
             }
             return builderResult.status
         }
         set (value) {
             builderResult.hasStatus = true
             builderResult.status = value
         }
    }
    private var statusBuilder_:Status.Builder! {
         didSet {
            builderResult.hasStatus = true
         }
    }
    public func getStatusBuilder() -> Status.Builder {
      if statusBuilder_ == nil {
         statusBuilder_ = Status.Builder()
         builderResult.status = statusBuilder_.getMessage()
         if status != nil {
            try! statusBuilder_.mergeFrom(status)
         }
      }
      return statusBuilder_
    }
    public func setStatus(value:Status!) -> GroupRemoveResponse.Builder {
      self.status = value
      return self
    }
    public func mergeStatus(value:Status) throws -> GroupRemoveResponse.Builder {
      if builderResult.hasStatus {
        builderResult.status = try Status.builderWithPrototype(builderResult.status).mergeFrom(value).buildPartial()
      } else {
        builderResult.status = value
      }
      builderResult.hasStatus = true
      return self
    }
    public func clearStatus() -> GroupRemoveResponse.Builder {
      statusBuilder_ = nil
      builderResult.hasStatus = false
      builderResult.status = nil
      return self
    }
    public var hasTeamKey:Bool {
         get {
              return builderResult.hasTeamKey
         }
    }
    public var teamKey:String {
         get {
              return builderResult.teamKey
         }
         set (value) {
             builderResult.hasTeamKey = true
             builderResult.teamKey = value
         }
    }
    public func setTeamKey(value:String) -> GroupRemoveResponse.Builder {
      self.teamKey = value
      return self
    }
    public func clearTeamKey() -> GroupRemoveResponse.Builder{
         builderResult.hasTeamKey = false
         builderResult.teamKey = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> GroupRemoveResponse.Builder {
      builderResult = GroupRemoveResponse()
      return self
    }
    public override func clone() throws -> GroupRemoveResponse.Builder {
      return try GroupRemoveResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> GroupRemoveResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> GroupRemoveResponse {
      let returnMe:GroupRemoveResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:GroupRemoveResponse) throws -> GroupRemoveResponse.Builder {
      if other == GroupRemoveResponse() {
       return self
      }
      if (other.hasStatus) {
          try mergeStatus(other.status)
      }
      if other.hasTeamKey {
           teamKey = other.teamKey
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> GroupRemoveResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GroupRemoveResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder:Status.Builder = Status.Builder()
          if hasStatus {
            try subBuilder.mergeFrom(status)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          status = subBuilder.buildPartial()

        case 18 :
          teamKey = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class GroupAddMemberResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var status:Status!
  public private(set) var hasStatus:Bool = false
  public private(set) var teamKey:String = ""

  public private(set) var hasTeamKey:Bool = false
  public private(set) var member:User!
  public private(set) var hasMember:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasStatus {
      try output.writeMessage(1, value:status)
    }
    if hasTeamKey {
      try output.writeString(2, value:teamKey)
    }
    if hasMember {
      try output.writeMessage(3, value:member)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasStatus {
        if let varSizestatus = status?.computeMessageSize(1) {
            serialize_size += varSizestatus
        }
    }
    if hasTeamKey {
      serialize_size += teamKey.computeStringSize(2)
    }
    if hasMember {
        if let varSizemember = member?.computeMessageSize(3) {
            serialize_size += varSizemember
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<GroupAddMemberResponse> {
    var mergedArray = Array<GroupAddMemberResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> GroupAddMemberResponse? {
    return try GroupAddMemberResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> GroupAddMemberResponse {
    return try GroupAddMemberResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> GroupAddMemberResponse {
    return try GroupAddMemberResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> GroupAddMemberResponse {
    return try GroupAddMemberResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> GroupAddMemberResponse {
    return try GroupAddMemberResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> GroupAddMemberResponse {
    return try GroupAddMemberResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GroupAddMemberResponse {
    return try GroupAddMemberResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> GroupAddMemberResponse.Builder {
    return GroupAddMemberResponse.classBuilder() as! GroupAddMemberResponse.Builder
  }
  public func getBuilder() -> GroupAddMemberResponse.Builder {
    return classBuilder() as! GroupAddMemberResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return GroupAddMemberResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return GroupAddMemberResponse.Builder()
  }
  public func toBuilder() throws -> GroupAddMemberResponse.Builder {
    return try GroupAddMemberResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:GroupAddMemberResponse) throws -> GroupAddMemberResponse.Builder {
    return try GroupAddMemberResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasStatus {
      output += "\(indent) status {\n"
      if let outDescStatus = status {
        output += try outDescStatus.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasTeamKey {
      output += "\(indent) teamKey: \(teamKey) \n"
    }
    if hasMember {
      output += "\(indent) member {\n"
      if let outDescMember = member {
        output += try outDescMember.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasStatus {
              if let hashValuestatus = status?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuestatus
              }
          }
          if hasTeamKey {
             hashCode = (hashCode &* 31) &+ teamKey.hashValue
          }
          if hasMember {
              if let hashValuemember = member?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuemember
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "GroupAddMemberResponse"
  }
  override public func className() -> String {
      return "GroupAddMemberResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return GroupAddMemberResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:GroupAddMemberResponse = GroupAddMemberResponse()
    public func getMessage() -> GroupAddMemberResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasStatus:Bool {
         get {
             return builderResult.hasStatus
         }
    }
    public var status:Status! {
         get {
             if statusBuilder_ != nil {
                builderResult.status = statusBuilder_.getMessage()
             }
             return builderResult.status
         }
         set (value) {
             builderResult.hasStatus = true
             builderResult.status = value
         }
    }
    private var statusBuilder_:Status.Builder! {
         didSet {
            builderResult.hasStatus = true
         }
    }
    public func getStatusBuilder() -> Status.Builder {
      if statusBuilder_ == nil {
         statusBuilder_ = Status.Builder()
         builderResult.status = statusBuilder_.getMessage()
         if status != nil {
            try! statusBuilder_.mergeFrom(status)
         }
      }
      return statusBuilder_
    }
    public func setStatus(value:Status!) -> GroupAddMemberResponse.Builder {
      self.status = value
      return self
    }
    public func mergeStatus(value:Status) throws -> GroupAddMemberResponse.Builder {
      if builderResult.hasStatus {
        builderResult.status = try Status.builderWithPrototype(builderResult.status).mergeFrom(value).buildPartial()
      } else {
        builderResult.status = value
      }
      builderResult.hasStatus = true
      return self
    }
    public func clearStatus() -> GroupAddMemberResponse.Builder {
      statusBuilder_ = nil
      builderResult.hasStatus = false
      builderResult.status = nil
      return self
    }
    public var hasTeamKey:Bool {
         get {
              return builderResult.hasTeamKey
         }
    }
    public var teamKey:String {
         get {
              return builderResult.teamKey
         }
         set (value) {
             builderResult.hasTeamKey = true
             builderResult.teamKey = value
         }
    }
    public func setTeamKey(value:String) -> GroupAddMemberResponse.Builder {
      self.teamKey = value
      return self
    }
    public func clearTeamKey() -> GroupAddMemberResponse.Builder{
         builderResult.hasTeamKey = false
         builderResult.teamKey = ""
         return self
    }
    public var hasMember:Bool {
         get {
             return builderResult.hasMember
         }
    }
    public var member:User! {
         get {
             if memberBuilder_ != nil {
                builderResult.member = memberBuilder_.getMessage()
             }
             return builderResult.member
         }
         set (value) {
             builderResult.hasMember = true
             builderResult.member = value
         }
    }
    private var memberBuilder_:User.Builder! {
         didSet {
            builderResult.hasMember = true
         }
    }
    public func getMemberBuilder() -> User.Builder {
      if memberBuilder_ == nil {
         memberBuilder_ = User.Builder()
         builderResult.member = memberBuilder_.getMessage()
         if member != nil {
            try! memberBuilder_.mergeFrom(member)
         }
      }
      return memberBuilder_
    }
    public func setMember(value:User!) -> GroupAddMemberResponse.Builder {
      self.member = value
      return self
    }
    public func mergeMember(value:User) throws -> GroupAddMemberResponse.Builder {
      if builderResult.hasMember {
        builderResult.member = try User.builderWithPrototype(builderResult.member).mergeFrom(value).buildPartial()
      } else {
        builderResult.member = value
      }
      builderResult.hasMember = true
      return self
    }
    public func clearMember() -> GroupAddMemberResponse.Builder {
      memberBuilder_ = nil
      builderResult.hasMember = false
      builderResult.member = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> GroupAddMemberResponse.Builder {
      builderResult = GroupAddMemberResponse()
      return self
    }
    public override func clone() throws -> GroupAddMemberResponse.Builder {
      return try GroupAddMemberResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> GroupAddMemberResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> GroupAddMemberResponse {
      let returnMe:GroupAddMemberResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:GroupAddMemberResponse) throws -> GroupAddMemberResponse.Builder {
      if other == GroupAddMemberResponse() {
       return self
      }
      if (other.hasStatus) {
          try mergeStatus(other.status)
      }
      if other.hasTeamKey {
           teamKey = other.teamKey
      }
      if (other.hasMember) {
          try mergeMember(other.member)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> GroupAddMemberResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GroupAddMemberResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder:Status.Builder = Status.Builder()
          if hasStatus {
            try subBuilder.mergeFrom(status)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          status = subBuilder.buildPartial()

        case 18 :
          teamKey = try input.readString()

        case 26 :
          let subBuilder:User.Builder = User.Builder()
          if hasMember {
            try subBuilder.mergeFrom(member)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          member = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class GroupRemoveMemberResponse : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var status:Status!
  public private(set) var hasStatus:Bool = false
  public private(set) var teamKey:String = ""

  public private(set) var hasTeamKey:Bool = false
  public private(set) var member:String = ""

  public private(set) var hasMember:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasStatus {
      try output.writeMessage(1, value:status)
    }
    if hasTeamKey {
      try output.writeString(2, value:teamKey)
    }
    if hasMember {
      try output.writeString(3, value:member)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasStatus {
        if let varSizestatus = status?.computeMessageSize(1) {
            serialize_size += varSizestatus
        }
    }
    if hasTeamKey {
      serialize_size += teamKey.computeStringSize(2)
    }
    if hasMember {
      serialize_size += member.computeStringSize(3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<GroupRemoveMemberResponse> {
    var mergedArray = Array<GroupRemoveMemberResponse>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> GroupRemoveMemberResponse? {
    return try GroupRemoveMemberResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> GroupRemoveMemberResponse {
    return try GroupRemoveMemberResponse.Builder().mergeFromData(data, extensionRegistry:ResponseRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> GroupRemoveMemberResponse {
    return try GroupRemoveMemberResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> GroupRemoveMemberResponse {
    return try GroupRemoveMemberResponse.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> GroupRemoveMemberResponse {
    return try GroupRemoveMemberResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> GroupRemoveMemberResponse {
    return try GroupRemoveMemberResponse.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GroupRemoveMemberResponse {
    return try GroupRemoveMemberResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> GroupRemoveMemberResponse.Builder {
    return GroupRemoveMemberResponse.classBuilder() as! GroupRemoveMemberResponse.Builder
  }
  public func getBuilder() -> GroupRemoveMemberResponse.Builder {
    return classBuilder() as! GroupRemoveMemberResponse.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return GroupRemoveMemberResponse.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return GroupRemoveMemberResponse.Builder()
  }
  public func toBuilder() throws -> GroupRemoveMemberResponse.Builder {
    return try GroupRemoveMemberResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:GroupRemoveMemberResponse) throws -> GroupRemoveMemberResponse.Builder {
    return try GroupRemoveMemberResponse.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasStatus {
      output += "\(indent) status {\n"
      if let outDescStatus = status {
        output += try outDescStatus.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasTeamKey {
      output += "\(indent) teamKey: \(teamKey) \n"
    }
    if hasMember {
      output += "\(indent) member: \(member) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasStatus {
              if let hashValuestatus = status?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuestatus
              }
          }
          if hasTeamKey {
             hashCode = (hashCode &* 31) &+ teamKey.hashValue
          }
          if hasMember {
             hashCode = (hashCode &* 31) &+ member.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "GroupRemoveMemberResponse"
  }
  override public func className() -> String {
      return "GroupRemoveMemberResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return GroupRemoveMemberResponse.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:GroupRemoveMemberResponse = GroupRemoveMemberResponse()
    public func getMessage() -> GroupRemoveMemberResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasStatus:Bool {
         get {
             return builderResult.hasStatus
         }
    }
    public var status:Status! {
         get {
             if statusBuilder_ != nil {
                builderResult.status = statusBuilder_.getMessage()
             }
             return builderResult.status
         }
         set (value) {
             builderResult.hasStatus = true
             builderResult.status = value
         }
    }
    private var statusBuilder_:Status.Builder! {
         didSet {
            builderResult.hasStatus = true
         }
    }
    public func getStatusBuilder() -> Status.Builder {
      if statusBuilder_ == nil {
         statusBuilder_ = Status.Builder()
         builderResult.status = statusBuilder_.getMessage()
         if status != nil {
            try! statusBuilder_.mergeFrom(status)
         }
      }
      return statusBuilder_
    }
    public func setStatus(value:Status!) -> GroupRemoveMemberResponse.Builder {
      self.status = value
      return self
    }
    public func mergeStatus(value:Status) throws -> GroupRemoveMemberResponse.Builder {
      if builderResult.hasStatus {
        builderResult.status = try Status.builderWithPrototype(builderResult.status).mergeFrom(value).buildPartial()
      } else {
        builderResult.status = value
      }
      builderResult.hasStatus = true
      return self
    }
    public func clearStatus() -> GroupRemoveMemberResponse.Builder {
      statusBuilder_ = nil
      builderResult.hasStatus = false
      builderResult.status = nil
      return self
    }
    public var hasTeamKey:Bool {
         get {
              return builderResult.hasTeamKey
         }
    }
    public var teamKey:String {
         get {
              return builderResult.teamKey
         }
         set (value) {
             builderResult.hasTeamKey = true
             builderResult.teamKey = value
         }
    }
    public func setTeamKey(value:String) -> GroupRemoveMemberResponse.Builder {
      self.teamKey = value
      return self
    }
    public func clearTeamKey() -> GroupRemoveMemberResponse.Builder{
         builderResult.hasTeamKey = false
         builderResult.teamKey = ""
         return self
    }
    public var hasMember:Bool {
         get {
              return builderResult.hasMember
         }
    }
    public var member:String {
         get {
              return builderResult.member
         }
         set (value) {
             builderResult.hasMember = true
             builderResult.member = value
         }
    }
    public func setMember(value:String) -> GroupRemoveMemberResponse.Builder {
      self.member = value
      return self
    }
    public func clearMember() -> GroupRemoveMemberResponse.Builder{
         builderResult.hasMember = false
         builderResult.member = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> GroupRemoveMemberResponse.Builder {
      builderResult = GroupRemoveMemberResponse()
      return self
    }
    public override func clone() throws -> GroupRemoveMemberResponse.Builder {
      return try GroupRemoveMemberResponse.builderWithPrototype(builderResult)
    }
    public override func build() throws -> GroupRemoveMemberResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> GroupRemoveMemberResponse {
      let returnMe:GroupRemoveMemberResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:GroupRemoveMemberResponse) throws -> GroupRemoveMemberResponse.Builder {
      if other == GroupRemoveMemberResponse() {
       return self
      }
      if (other.hasStatus) {
          try mergeStatus(other.status)
      }
      if other.hasTeamKey {
           teamKey = other.teamKey
      }
      if other.hasMember {
           member = other.member
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> GroupRemoveMemberResponse.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GroupRemoveMemberResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder:Status.Builder = Status.Builder()
          if hasStatus {
            try subBuilder.mergeFrom(status)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          status = subBuilder.buildPartial()

        case 18 :
          teamKey = try input.readString()

        case 26 :
          member = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}


// @@protoc_insertion_point(global_scope)
